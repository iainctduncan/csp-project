%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Musical Constraint Satisfication Programming Project}
\date{Aug 18, 2024}
\release{1.0}
\author{Iain C.T.\@{} Duncan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
The objective of this project is to implement an algorithmic musical line builder as
a constraint satisfaction problem using a custom\sphinxhyphen{}buit domain\sphinxhyphen{}specific solver in the
Scheme programming language such that it can be run in the Scheme for Max computer music environment.
The solver will allow the user (i.e., the programmer using the solver in a Scheme
for Max program) to specify constraints by registering predicate functions that take
a standardized set of arguments and that work over symbolic musical representation.
It is assumed that the user has familiarity with the Scheme language, but not necessarily
with the details of CSP programming, and that the user is comfortable with basic music theory.
The project will provide a Scheme message\sphinxhyphen{}passing\sphinxhyphen{}style object that acts as a CSP solver,
along with a library of symbolic functions allowing the user to make new constraint predicates
relatively easily, working with familiar musical symbols.

\sphinxAtStartPar
The test application for the project is a program that builds walking idiomatic
jazz walking bass lines, given a key, a starting note, and a symbolic chord progression such as IImin7 V7 IMaj7.
The test application will return the realized bass line as set of symbolic note names (e.g., D4 F4 A4).


\chapter{Specific Goals}
\label{\detokenize{index:specific-goals}}
\sphinxAtStartPar
Specific goals of the implementation are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Constraints may be either local (run over one variable) or global. A solution will satisfy all local and global constraints.

\item {} 
\sphinxAtStartPar
Constraints may be easily created in high\sphinxhyphen{}level Scheme using an included set of musical primitives.

\item {} 
\sphinxAtStartPar
Multiple runs of the program will create different bass\sphinxhyphen{}lines, i.e., the CSP solver is
not looking for the first or best solution, but rather a stochastically chosen acceptable solution.

\item {} 
\sphinxAtStartPar
The solver will find a solution if one exists, this at the possible expense of execution speed.

\item {} 
\sphinxAtStartPar
If the constraints given result in an unsolvable problem, the solver will determine this and return false.

\item {} 
\sphinxAtStartPar
Solutions will be rendered bar\sphinxhyphen{}by\sphinxhyphen{}bar, such that it would be possible for the solver to be used
to play algorithmically\sphinxhyphen{}generated lines in real time and for infinite time, so long as the solver
can generate a bar’s notes in less time than is used to play a bar.

\item {} 
\sphinxAtStartPar
The solver will accept constraints using symbols of all note values (i.e., either C\# or Db may be used)
but will not necessarily return values translated into symbols appropriate to the key (i.e., it may
use either Db or C\# for note values, regardless of the context)

\end{itemize}


\chapter{Program Structure}
\label{\detokenize{index:program-structure}}
\sphinxAtStartPar
The solver is implemented as a Scheme function\sphinxhyphen{}as\sphinxhyphen{}an\sphinxhyphen{}object that receives symbolic messages and that stores local values in private scope.
This is implemented by using a builder function that creates a local let\sphinxhyphen{}block, and returns a lambda function with
access to the values in the let. The returned function acts as the object, and methods can be called by passing
symbolic messages, which are dispatched to similarly named functions with the local scope.
By implementing the solver as a self contained object, the user of the solver must thus only load the code defining the csp solver
builder function, and any musical library functions used to build constraints.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; example of the the message passing object structure used}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{make\PYGZhy{}obj}\PYG{p}{)}
\PYG{+w}{  }\PYG{c+c1}{; object state is stored in a hash\PYGZhy{}table with keyword keys}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{hash\PYGZhy{}table}
\PYG{+w}{              }\PYG{n+nv}{:var\PYGZhy{}1}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}t}
\PYG{+w}{              }\PYG{n+nv}{:var\PYGZhy{}2}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{    }\PYG{c+c1}{; a method to return a state var}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{get\PYGZhy{}var}\PYG{+w}{ }\PYG{n+nv}{var\PYGZhy{}name}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{var\PYGZhy{}name}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{    }\PYG{c+c1}{; a method to update a state var}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{set\PYGZhy{}var!}\PYG{+w}{ }\PYG{n+nv}{var\PYGZhy{}name}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{var\PYGZhy{}name}\PYG{p}{)}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{    }\PYG{c+c1}{; dispatch method is a lambda returned by make\PYGZhy{}obj}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{lambda}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{msg}\PYG{+w}{ }\PYG{o}{.}\PYG{+w}{ }\PYG{n+nv}{args}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{(}\PYG{n+nb}{apply}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{eval}\PYG{+w}{ }\PYG{n+nv}{msg}\PYG{p}{)}\PYG{+w}{ }\PYG{n+nv}{args}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{; make an object}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{n+nv}{my\PYGZhy{}obj}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{make\PYGZhy{}obj}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{; set var\PYGZhy{}2 to value of var\PYGZhy{}1}
\PYG{p}{(}\PYG{n+nf}{my\PYGZhy{}obj}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}set\PYGZhy{}var}\PYG{+w}{ }\PYG{n+nv}{:var\PYGZhy{}2}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{my\PYGZhy{}obj}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}get}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}var\PYGZhy{}1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The solver is set up via an explicit initialization method, allowing the same solver to be reused for subsequent
bars by only setting the values that need to change for each bar by reinitializing the solver object.

\sphinxAtStartPar
Constraints are added via a registration function that accepts a predicate function, the variable over which it runs,
and a symbolic name. Global constraints are similarly added, but are assumed to have access to all notes.

\sphinxAtStartPar
The solver’s \sphinxstylestrong{solve} method runs the solver, returning a list of symbolic notes.


\chapter{High\sphinxhyphen{}level Implementation of the Solver}
\label{\detokenize{index:high-level-implementation-of-the-solver}}
\sphinxAtStartPar
The solver contains two kinds of domain variables, note variables and context variables.

\sphinxAtStartPar
Notes are stored in a list and are assumed to be empty prior to solving, though are not necessarily so.
The domain of note variables is separately maintained in local state, and is set up during initialization
to contain MIDI note\sphinxhyphen{}names across a pre\sphinxhyphen{}determined range (e.g., C0 to B5).
The number of note variables is determined by an argument to the object builder,
and the problem is considered to be solved when values have been successfully assigned to
all note slots, satisfying all local and global constraints.
The use of MIDI note symbols rather than note numbers was chosen to facilitate interactive
debugging and exploratory coding.

\sphinxAtStartPar
Context variables are symbolic state variables for the solver and are assumed to be
pre\sphinxhyphen{}assigned prior to the solve method. While they can be changed in between calls to the solve method,
the solver does not assign context variables as part of finding a solution.

\sphinxAtStartPar
As the solver solves bar\sphinxhyphen{}by\sphinxhyphen{}bar, it must be aware of the bar to which it is leading.
In my test application, for example, to build an idiomatic jazz bass line with four notes per bar,
note 5 of the solution will always be the tonic of the subsequent bar, and note
4 will always be either a chromatic neighbour tone of this target.
Thus, we require the solver to have context for the current bar and the subsequent bar.

\sphinxAtStartPar
The context variables used are the following
\begin{quote}
\begin{description}
\sphinxlineitem{tonic}
\sphinxAtStartPar
The home key for the progression, as a pitch\sphinxhyphen{}class symbol (‘C, ‘Db, etc.)

\sphinxlineitem{tonality}
\sphinxAtStartPar
The tonality of the home key, as a symbol of ‘major, ‘minor, or ‘blues.

\sphinxlineitem{root}
\sphinxAtStartPar
The root of the chord for the line, as a Roman numeral symbol (‘I, ‘IV, etc.)

\sphinxlineitem{quality}
\sphinxAtStartPar
The chord quality for the line, as a chord symbol (‘Maj7, ‘Min7, etc)

\sphinxlineitem{target}
\sphinxAtStartPar
The chord root for the next bar, as a Roman numeral

\sphinxlineitem{target\sphinxhyphen{}q}
\sphinxAtStartPar
The chord quality of the target chord, as a chord symbol

\end{description}
\end{quote}

\sphinxAtStartPar
Initialization prior to solving for bar thus consists of passing a hash\sphinxhyphen{}table
of context variables to the \sphinxstylestrong{method}, which will copy values into the local
context state, and initialize the note variables to empty.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; a simplified example of building and running a solver}
\PYG{c+c1}{; the first argument to the solver is how many notes should be returned per bar}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{make\PYGZhy{}csp}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{; add a local and global constraint}
\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}constraint}\PYG{+w}{ }\PYG{n+nv}{chord\PYGZhy{}root?}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{  }\PYG{l+s+ss}{\PYGZsq{}n0\PYGZhy{}root}\PYG{p}{)}
\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}global\PYGZhy{}constraint}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{intv\PYGZhy{}under?}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}maj\PYGZhy{}3}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{; initialize the csp with context variables}
\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}init}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{hash\PYGZhy{}table}
\PYG{+w}{                  }\PYG{l+s+ss}{\PYGZsq{}tonic}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}C}
\PYG{+w}{                  }\PYG{l+s+ss}{\PYGZsq{}tonality}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}major}
\PYG{+w}{                  }\PYG{l+s+ss}{\PYGZsq{}root}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}I}
\PYG{+w}{                  }\PYG{l+s+ss}{\PYGZsq{}quality}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}Maj\PYGZhy{}7}
\PYG{+w}{                  }\PYG{l+s+ss}{\PYGZsq{}target}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}IV}
\PYG{+w}{                  }\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{ }\PYG{c+c1}{; solve}
\PYG{+w}{ }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{n+nv}{notes\PYGZhy{}out}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}solve}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Domain Model Functions}
\label{\detokenize{index:domain-model-functions}}
\sphinxAtStartPar
The project includes a file of domain specific helper functions necessary for building
constraints with symbolic notes and rules. These allow us to work with:
\begin{quote}
\begin{description}
\sphinxlineitem{note symbols}
\sphinxAtStartPar
MIDI note symbols that indicate pitch and octave such as C0, Db0, etc.

\sphinxlineitem{pitch class symbols}
\sphinxAtStartPar
Symbols for the pitch alone: C, Db, D, etc.

\sphinxlineitem{note numbers}
\sphinxAtStartPar
MIDI note numbers from 0 to 127

\sphinxlineitem{roman numerals}
\sphinxAtStartPar
Numerals to indicate chord function, I, II, III, etc.

\sphinxlineitem{chord quality symbols}
\sphinxAtStartPar
Symbols for a type of chord: Maj7

\sphinxlineitem{interval symbols}
\sphinxAtStartPar
Symbolic intervals, used to define qualities (min\sphinxhyphen{}3, prf\sphinxhyphen{}5, etc.)

\end{description}
\end{quote}

\sphinxAtStartPar
The helper libary provides translation functions between these symbolic and numeric
representations. A current limitation is that pitch classes are assumed to use flats only,
but the structure of the library is such that this can be easily extended
to include all symbolic note names.

\sphinxAtStartPar
Where possible, translation functions are implemented to use hash\sphinxhyphen{}tables as a form
of caching, this to avoid unecessary calculation during constraint execution, which
may run many times for a solve pass. Some of the translation functions are simply
prepopulated in code, while others are populated dynamically when the helper
library is imported.

\sphinxAtStartPar
The nomenclature used in helper function names is:
\begin{quote}
\begin{description}
\sphinxlineitem{\sphinxstylestrong{int}}
\sphinxAtStartPar
refers to an integer offset of a pitch (e.g., C == 0, D ==2)

\sphinxlineitem{\sphinxstylestrong{note\sphinxhyphen{}num}}
\sphinxAtStartPar
refers to MIDI note numbers

\sphinxlineitem{\sphinxstylestrong{pitch}}
\sphinxAtStartPar
refers to symbolic pitch class (C, D, …)

\sphinxlineitem{\sphinxstylestrong{note}}
\sphinxAtStartPar
refers to a symbolic note of pitch class and octave

\sphinxlineitem{\sphinxstylestrong{oct}}
\sphinxAtStartPar
refers to the integer octave as used in MIDI note names

\sphinxlineitem{\sphinxstylestrong{interval}}
\sphinxAtStartPar
refers to a symbolic interval (min\sphinxhyphen{}3, prf\sphinxhyphen{}4, …)

\sphinxlineitem{\sphinxstylestrong{rnum}}
\sphinxAtStartPar
refers to a Roman numeral symbol (I, II, …)

\sphinxlineitem{\sphinxstylestrong{chord}}
\sphinxAtStartPar
refers to a chord quality symbol (Maj7, Min7, etc.)

\end{description}
\end{quote}

\sphinxAtStartPar
Helper functions provided by the library include the below,
where the components are the above, and \sphinxhyphen{}\textgreater{} indicates a translation.
Hyphenated components and plurals indicate a list input or output.
\begin{itemize}
\item {} 
\sphinxAtStartPar
pitch\sphinxhyphen{}\textgreater{}int

\item {} 
\sphinxAtStartPar
int\sphinxhyphen{}\textgreater{}pitch

\item {} 
\sphinxAtStartPar
interval\sphinxhyphen{}\textgreater{}semitones

\item {} 
\sphinxAtStartPar
semitones\sphinxhyphen{}\textgreater{}interval

\item {} 
\sphinxAtStartPar
note\sphinxhyphen{}\textgreater{}pitch

\item {} 
\sphinxAtStartPar
note\sphinxhyphen{}\textgreater{}oct

\item {} 
\sphinxAtStartPar
note\sphinxhyphen{}\textgreater{}note\sphinxhyphen{}num

\item {} 
\sphinxAtStartPar
semitones\sphinxhyphen{}between

\item {} 
\sphinxAtStartPar
interval\sphinxhyphen{}between

\item {} 
\sphinxAtStartPar
chord\sphinxhyphen{}intervals

\item {} 
\sphinxAtStartPar
chord\sphinxhyphen{}\textgreater{}semitones

\item {} 
\sphinxAtStartPar
rnum\sphinxhyphen{}\textgreater{}int

\item {} 
\sphinxAtStartPar
root\sphinxhyphen{}pitch

\item {} 
\sphinxAtStartPar
root\sphinxhyphen{}chord\sphinxhyphen{}\textgreater{}note\sphinxhyphen{}nums

\item {} 
\sphinxAtStartPar
root\sphinxhyphen{}chord\sphinxhyphen{}\textgreater{}pitches

\end{itemize}


\chapter{Local Constraints}
\label{\detokenize{index:local-constraints}}
\sphinxAtStartPar
Constraints are implemented as boolean predicate functions with standard arguments
that give the predicate access to the csp solver’s state (and thus context).
Local constaints are passed a reference to the csp object, an integer corresponding
the note variable index, and the value being tested as a MIDI note symbols.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; a local constraint example}
\PYG{c+c1}{; checks if the value under test is the same pitch\PYGZhy{}class as the context}
\PYG{c+c1}{; variable for the tonic of key}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{is\PYGZhy{}tonic?}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{tonic}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}get\PYGZhy{}var}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}tonic}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{c+c1}{; the note\PYGZhy{}\PYGZgt{}pitch helper returns a pitch\PYGZhy{}class symbol from a note symbol}
\PYG{+w}{         }\PYG{p}{(}\PYG{n+nf}{res}\PYG{+w}{   }\PYG{p}{(}\PYG{n+nb}{eq?}\PYG{+w}{ }\PYG{n+nv}{tonic}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{note\PYGZhy{}\PYGZgt{}pitch}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nv}{res}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{; registering the constraint, using the registration name \PYGZsq{}is\PYGZhy{}tonic}
\PYG{c+c1}{; it is registered as running over the tonic context var and note 0}
\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}constraint}\PYG{+w}{ }\PYG{n+nv}{is\PYGZhy{}tonic?}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{n+nv}{tonic}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}is\PYGZhy{}tonic}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
As constraints are registered using a reference to a function, we can also
implement higher\sphinxhyphen{}level constraint builders.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{is\PYGZhy{}chord\PYGZhy{}factor?}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{+w}{ }\PYG{n+nv}{factor}\PYG{p}{)}
\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{return true if note pitch class is the given factor of the chord}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{root}\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}get\PYGZhy{}var}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}root}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{p}{(}\PYG{n+nf}{chord\PYGZhy{}q}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}get\PYGZhy{}var}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}quality}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{p}{(}\PYG{n+nf}{chord\PYGZhy{}pitches}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{root\PYGZhy{}chord\PYGZhy{}\PYGZgt{}pitches}\PYG{+w}{ }\PYG{n+nv}{root}\PYG{+w}{ }\PYG{n+nv}{chord\PYGZhy{}q}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{p}{(}\PYG{n+nf}{val\PYGZhy{}pitch}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{note\PYGZhy{}\PYGZgt{}pitch}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{         }\PYG{p}{(}\PYG{n+nf}{res}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{enh\PYGZhy{}eq?}\PYG{+w}{ }\PYG{n+nv}{val\PYGZhy{}pitch}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{chord\PYGZhy{}pitches}\PYG{+w}{ }\PYG{n+nv}{factor}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nv}{res}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{; register a function that checks if the note is the third of the chord}
\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}constraint}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{lambda}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{is\PYGZhy{}chord\PYGZhy{}factor?}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{+w}{ }\PYG{n+nv}{val}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}is\PYGZhy{}third}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
During the solve process, the solver users the \sphinxstylestrong{get\sphinxhyphen{}applicable\sphinxhyphen{}constraints} method
to find all local constraints that can be run on a given assignment pass, running
them prior to the assignment of value to a note variable.


\chapter{Global Constraints}
\label{\detokenize{index:global-constraints}}
\sphinxAtStartPar
Global constraints are implemented as predicates that have access to the entire
list of note variables, and are run post\sphinxhyphen{}assingment, with assignement rolled\sphinxhyphen{}back on failure.
They do not have any notion of the current variable being assigned, and
must thus be able to handle the case of incomplete note lists by returning true
to indicate a pass.
A future improvement would be to enable global constraint registration to indicate
which variables must be filled prior to running so that the constraint code
itself does not need to handle this.

\sphinxAtStartPar
For example, in the constraint to check if the last note of the bar is a chromatic
neighbour follwed by the target root, the constraint passes if we are missing any of the necessary domain variables,
and checks the relationship between the fourth and fifth note if we have them.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{target\PYGZhy{}from\PYGZhy{}cn?}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{+w}{ }\PYG{n+nv}{notes}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{or}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}get\PYGZhy{}var}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}target}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{c+c1}{; we don\PYGZsq{}t have enough to run the constraint, pass}
\PYG{+w}{    }\PYG{n+no}{\PYGZsh{}t}
\PYG{+w}{    }\PYG{c+c1}{; if we do, check that it is a chromatic step between notes 4 and 5}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{n\PYGZhy{}note}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{           }\PYG{p}{(}\PYG{n+nf}{t\PYGZhy{}note}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{           }\PYG{p}{(}\PYG{n+nf}{n\PYGZhy{}num}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{note\PYGZhy{}\PYGZgt{}note\PYGZhy{}num}\PYG{+w}{ }\PYG{n+nv}{n\PYGZhy{}note}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{           }\PYG{p}{(}\PYG{n+nf}{t\PYGZhy{}num}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{note\PYGZhy{}\PYGZgt{}note\PYGZhy{}num}\PYG{+w}{ }\PYG{n+nv}{t\PYGZhy{}note}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{           }\PYG{p}{(}\PYG{n+nf}{res}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{abs}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{\PYGZhy{}}\PYG{+w}{ }\PYG{n+nv}{t\PYGZhy{}num}\PYG{+w}{ }\PYG{n+nv}{n\PYGZhy{}num}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nv}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
With the current implementation, one could thus implement a brute\sphinxhyphen{}force solver using only global constraints.

\sphinxAtStartPar
The library of constraints includes an imperative implementation of all\sphinxhyphen{}diff, as well
as a more specific implementation that accepts a list of notes which must be different.
This was necessary for the test program, for example, as the chromatic neighbour
of a target root may or may not be already in the chord. We thus need a way to specify,
“all notes should be different, unless the duplicated note is the chromatic neighbour as note 4”.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; fail on any already assigned notes that are duplicates}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{all\PYGZhy{}diff?}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{+w}{ }\PYG{n+nv}{notes}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{len}\PYG{+w}{   }\PYG{p}{(}\PYG{n+nb}{length}\PYG{+w}{ }\PYG{n+nv}{notes}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{n+nf}{pass}\PYG{+w}{  }\PYG{n+no}{\PYGZsh{}t}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{do}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{i}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{=}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{+w}{ }\PYG{n+nv}{len}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{do}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{j}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{=}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{+w}{ }\PYG{n+nv}{len}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{and}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{eq?}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{=}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{false?}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{          }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{n+nv}{pass}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nv}{pass}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{; diff is like all\PYGZhy{}diff but takes list of note vars}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{diff?}\PYG{+w}{ }\PYG{n+nv}{note\PYGZhy{}var\PYGZhy{}list}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{lambda}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{n+nv}{notes}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{len}\PYG{+w}{   }\PYG{p}{(}\PYG{n+nb}{length}\PYG{+w}{ }\PYG{n+nv}{notes}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{          }\PYG{p}{(}\PYG{n+nf}{pass}\PYG{+w}{  }\PYG{n+no}{\PYGZsh{}t}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{do}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{i}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{=}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{+w}{ }\PYG{n+nv}{len}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{do}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{j}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{=}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{+w}{ }\PYG{n+nv}{len}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{          }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{and}
\PYG{+w}{                }\PYG{p}{(}\PYG{n+nf}{in?}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{+w}{ }\PYG{n+nv}{note\PYGZhy{}var\PYGZhy{}list}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{(}\PYG{n+nf}{in?}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{+w}{ }\PYG{n+nv}{note\PYGZhy{}var\PYGZhy{}list}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{(}\PYG{n+nb}{eq?}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{=}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{+w}{ }\PYG{n+nv}{j}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{false?}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{notes}\PYG{+w}{ }\PYG{n+nv}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{k}{begin}
\PYG{+w}{              }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{n+nv}{pass}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nv}{pass}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Constraints for the Test Problem}
\label{\detokenize{index:constraints-for-the-test-problem}}
\sphinxAtStartPar
Given the above constraints, we have what we need to specify an arpeggiated bass line
that always leads chromatically into the next chord.
Our rules are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first note must be the root of the chord

\item {} 
\sphinxAtStartPar
The second and third notes must in the chord

\item {} 
\sphinxAtStartPar
None of the first three notes may be the same

\item {} 
\sphinxAtStartPar
Adjacent notes are under a major 3rd apart

\item {} 
\sphinxAtStartPar
The final note is the root of the target chord

\item {} 
\sphinxAtStartPar
The penultimate note is a chromatic neighbour of the target

\end{itemize}

\sphinxAtStartPar
In the test program, this is implemented as a function to add these constraints.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{add\PYGZhy{}constraints}\PYG{+w}{ }\PYG{n+nv}{csp}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}constraint}\PYG{+w}{ }\PYG{n+nv}{chord\PYGZhy{}root?}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{  }\PYG{l+s+ss}{\PYGZsq{}n0\PYGZhy{}root}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}constraint}\PYG{+w}{ }\PYG{n+nv}{in\PYGZhy{}chord?}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}in\PYGZhy{}chord\PYGZhy{}1}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}constraint}\PYG{+w}{ }\PYG{n+nv}{in\PYGZhy{}chord?}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}in\PYGZhy{}chord\PYGZhy{}2}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}constraint}\PYG{+w}{ }\PYG{n+nv}{target\PYGZhy{}root?}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}target\PYGZhy{}root}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}global\PYGZhy{}constraint}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{diff?}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}global\PYGZhy{}constraint}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{intv\PYGZhy{}under?}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}maj\PYGZhy{}3}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{csp}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZsq{}add\PYGZhy{}global\PYGZhy{}constraint}\PYG{+w}{ }\PYG{n+nv}{target\PYGZhy{}from\PYGZhy{}cn?}\PYG{p}{)}
\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Solver Implementation}
\label{\detokenize{index:solver-implementation}}
\sphinxAtStartPar
The solving algorithm is a recursive tree walk, where the depth corresponds to the
index within the list of notes. This is implemented in the csp object’s \sphinxstylestrong{solve} method.
The solve method contains an inner recursive function, \sphinxstylestrong{recursive\sphinxhyphen{}search}, which
is passed a boolean result and a depth, but also as access to the note variable assignment list
as this is in scope of the function\sphinxhyphen{}object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; the main search method, fills and returns the notes vars on success}
\PYG{c+c1}{; can take optional positional arg of hash\PYGZhy{}table of preassignments}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{solve}\PYG{+w}{ }\PYG{o}{.}\PYG{+w}{ }\PYG{n+nv}{args}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{\PYGZgt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{length}\PYG{+w}{ }\PYG{n+nv}{args}\PYG{p}{)}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{n+nf}{pre\PYGZhy{}assign}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{args}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{post}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{csp::(solve) ctx:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:cxt\PYGZhy{}assignments}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{notes:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{  }\PYG{c+c1}{; inner recursive function}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{recursive\PYGZhy{}search}\PYG{+w}{ }\PYG{n+nv}{result}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{p}{)}
\PYG{+w}{  }\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first check is whether all notes have been assigned, and if this is the case,
a \sphinxstylestrong{\#true} value is returned up the stack.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; inner recursive function}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{recursive\PYGZhy{}search}\PYG{+w}{ }\PYG{n+nv}{result}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{p}{)}
\PYG{+w}{  }\PYG{c+c1}{;if assignment complete, we are done return assignment}
\PYG{+w}{  }\PYG{c+c1}{;(post \PYGZdq{}\PYGZdq{})}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{post}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{csp::solve::(search) depth:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{notes:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{    }\PYG{c+c1}{; case done, vector of 4 notes filled, return success}
\PYG{+w}{    }\PYG{c+c1}{; executes when we get to the bottom of recuring down}
\PYG{+w}{    }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{all\PYGZhy{}notes\PYGZhy{}assigned?}\PYG{p}{)}
\PYG{+w}{       }\PYG{c+c1}{;(post \PYGZdq{}  \PYGZhy{} all note assigned, returning \PYGZsh{}t up stack\PYGZdq{})}
\PYG{+w}{       }\PYG{n+no}{\PYGZsh{}t}\PYG{p}{)}
\PYG{+w}{    }\PYG{c+c1}{; else we still have notes to fill}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{else}
\PYG{+w}{      }\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
If it is not, the next variable to solve is selected using the \sphinxstylestrong{select\sphinxhyphen{}var} method,
and the solver then iterates through all possible domain values for this variable,
using a named\sphinxhyphen{}let block as a loop, with a recursively reduced list of domain values
passed into each iteraction (a.k.a. “a list eater function”, though implemented as a
named\sphinxhyphen{}let rather than a lambda function).

\sphinxAtStartPar
If all domain values have been exhausted (the list is null), we return \sphinxstylestrong{\#f} up the stack.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; else we still have notes to fill}
\PYG{p}{(}\PYG{k}{else}
\PYG{+w}{  }\PYG{c+c1}{; get the next far to fill}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{var}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{select\PYGZhy{}var}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{c+c1}{; iterate through domain values for i}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{n+nv}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{vals}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{get\PYGZhy{}domain\PYGZhy{}values}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{c+c1}{;(post \PYGZdq{}domain\PYGZhy{}val\PYGZhy{}loop: domain\PYGZhy{}vals:\PYGZdq{} vals)}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}
\PYG{+w}{        }\PYG{c+c1}{; case ran out of domain vals, return failure back up}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{begin}
\PYG{+w}{          }\PYG{c+c1}{;(post \PYGZdq{} \PYGZhy{} out of possible domain values, return \PYGZsh{}f up stack\PYGZdq{})}
\PYG{+w}{          }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}
\PYG{+w}{        }\PYG{c+c1}{; else, try assigning the val, check constraints we can run so far}
\end{sphinxVerbatim}

\sphinxAtStartPar
If there is a domain value remaining to be tested, it is checked against constraints
applicable to the current value, and assigned on pass. On failure, iteration continues.
Assuming the local constraints pass, the note variable is assigned and we proceed to
global constraints.

\sphinxAtStartPar
If global constraints pass, the note assignment is kept, and we proceed down one more
depth by recursively calling \sphinxstylestrong{recursive\sphinxhyphen{}search}, passing in the new depth and a value
of \sphinxstylestrong{\#true} for the result.

\sphinxAtStartPar
In the case that assignment and local constraints succeed but global constraints fail,
the assigned note is unassigned, and the domain value loop continues.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; get the next far to fill}
\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{var}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{select\PYGZhy{}var}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{c+c1}{; iterate through domain values for i}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{n+nv}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{vals}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{get\PYGZhy{}domain\PYGZhy{}values}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{c+c1}{;(post \PYGZdq{}domain\PYGZhy{}val\PYGZhy{}loop: domain\PYGZhy{}vals:\PYGZdq{} vals)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}
\PYG{+w}{      }\PYG{c+c1}{; case ran out of domain vals, return failure back up}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{begin}
\PYG{+w}{        }\PYG{c+c1}{;(post \PYGZdq{} \PYGZhy{} out of possible domain values, return \PYGZsh{}f up stack\PYGZdq{})}
\PYG{+w}{        }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}
\PYG{+w}{      }\PYG{c+c1}{; else, try assigning the val, check constraints we can run so far}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{passed}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{assign\PYGZhy{}if\PYGZhy{}valid}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{first}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{          }\PYG{c+c1}{; didn\PYGZsq{}t pass precheck, on to next possible domain value}
\PYG{+w}{          }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{n+nv}{passed}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nf}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{          }\PYG{c+c1}{; passed precheck, failed globals: unset and continue domain val loop}
\PYG{+w}{          }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{check\PYGZhy{}global\PYGZhy{}constraints}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{p}{)}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nf}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{          }\PYG{c+c1}{; passed everything, found value, recurse onwards}
\PYG{+w}{          }\PYG{c+c1}{; if recursing fails, unset var and continue looking}
\PYG{+w}{          }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{recursive\PYGZhy{}search}\PYG{+w}{ }\PYG{n+nv}{passed}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{p}{)}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nf}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{          }\PYG{p}{(}\PYG{k}{else}
\PYG{+w}{            }\PYG{c+c1}{;(post \PYGZdq{} \PYGZhy{} found passing domain val:\PYGZdq{} passed \PYGZdq{}for depth\PYGZdq{} depth \PYGZdq{}returning \PYGZsh{}t\PYGZdq{})}
\PYG{+w}{            }\PYG{n+no}{\PYGZsh{}t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the case that a solution is found, the enclosing method, \sphinxstylestrong{solve} returns
the note assignments in addition to the side effect of having the local note assignment
list populated, this to simplify using the csp object.
In the event of failure, it returns false.

\sphinxAtStartPar
The complete implementation of the backtracking search is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; the main search method, fills and returns the notes vars on success}
\PYG{c+c1}{; can take optional positional arg of hash\PYGZhy{}table of preassignments}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{solve}\PYG{+w}{ }\PYG{o}{.}\PYG{+w}{ }\PYG{n+nv}{args}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{\PYGZgt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{length}\PYG{+w}{ }\PYG{n+nv}{args}\PYG{p}{)}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{n+nf}{pre\PYGZhy{}assign}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{args}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{post}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SOLVING}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{n+nf}{post}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{csp::(solve) ctx:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:cxt\PYGZhy{}assignments}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{notes:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{  }\PYG{c+c1}{; this works with the object vals, not so sure if that is better than having it separate}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{recursive\PYGZhy{}search}\PYG{+w}{ }\PYG{n+nv}{result}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{p}{)}
\PYG{+w}{    }\PYG{c+c1}{;if assignment complete, we are done return assignment}
\PYG{+w}{    }\PYG{c+c1}{;(post \PYGZdq{}\PYGZdq{})}
\PYG{+w}{    }\PYG{p}{(}\PYG{n+nf}{post}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{csp::solve::(search) depth:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{notes:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{      }\PYG{c+c1}{; case done, vector of 4 notes filled, return success}
\PYG{+w}{      }\PYG{c+c1}{; executes when we get to the bottom of recuring down}
\PYG{+w}{      }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{all\PYGZhy{}notes\PYGZhy{}assigned?}\PYG{p}{)}
\PYG{+w}{         }\PYG{c+c1}{;(post \PYGZdq{}  \PYGZhy{} all note assigned, returning \PYGZsh{}t up stack\PYGZdq{})}
\PYG{+w}{         }\PYG{n+no}{\PYGZsh{}t}\PYG{p}{)}
\PYG{+w}{      }\PYG{c+c1}{; else we still have notes to fill}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{else}
\PYG{+w}{        }\PYG{c+c1}{; get the next far to fill}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{var}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{select\PYGZhy{}var}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{          }\PYG{c+c1}{; iterate through domain values for i}
\PYG{+w}{          }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{n+nv}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{vals}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{get\PYGZhy{}domain\PYGZhy{}values}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{            }\PYG{c+c1}{;(post \PYGZdq{}domain\PYGZhy{}val\PYGZhy{}loop: domain\PYGZhy{}vals:\PYGZdq{} vals)}
\PYG{+w}{            }\PYG{c+c1}{; test first value, if good, use it and recurse}
\PYG{+w}{            }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{null?}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}
\PYG{+w}{              }\PYG{c+c1}{; case ran out of domain vals, return failure back up}
\PYG{+w}{              }\PYG{p}{(}\PYG{k}{begin}
\PYG{+w}{                }\PYG{c+c1}{;(post \PYGZdq{} \PYGZhy{} out of possible domain values, return \PYGZsh{}f up stack\PYGZdq{})}
\PYG{+w}{                }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}
\PYG{+w}{              }\PYG{c+c1}{; else, try assigning the val, check constraints we can run so far}
\PYG{+w}{              }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{passed}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{assign\PYGZhy{}if\PYGZhy{}valid}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{first}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{                  }\PYG{c+c1}{; didn\PYGZsq{}t pass precheck, on to next possible domain value}
\PYG{+w}{                  }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{n+nv}{passed}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{(}\PYG{n+nf}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                  }\PYG{c+c1}{; passed precheck, failed globals: unset and continue domain val loop}
\PYG{+w}{                  }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{check\PYGZhy{}global\PYGZhy{}constraints}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{p}{)}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{(}\PYG{n+nf}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                  }\PYG{c+c1}{; passed everything, found value, recurse onwards}
\PYG{+w}{                  }\PYG{c+c1}{; if recursing fails, unset var and continue looking}
\PYG{+w}{                  }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{not}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{recursive\PYGZhy{}search}\PYG{+w}{ }\PYG{n+nv}{passed}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{+w}{ }\PYG{n+nv}{:note\PYGZhy{}assignments}\PYG{+w}{ }\PYG{n+nv}{var}\PYG{p}{)}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{(}\PYG{n+nf}{domain\PYGZhy{}val\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cdr}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                  }\PYG{p}{(}\PYG{k}{else}
\PYG{+w}{                    }\PYG{c+c1}{;(post \PYGZdq{} \PYGZhy{} found passing domain val:\PYGZdq{} passed \PYGZdq{}for depth\PYGZdq{} depth \PYGZdq{}returning \PYGZsh{}t\PYGZdq{})}
\PYG{+w}{                    }\PYG{n+no}{\PYGZsh{}t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Limitations}
\label{\detokenize{index:limitations}}

\section{Propagation}
\label{\detokenize{index:propagation}}
\sphinxAtStartPar
The current implementation is essentially a brute\sphinxhyphen{}force solver and does not (yet)
include any forward\sphinxhyphen{}propagation of constraints.
When constraints fail at a given depth, the solver will next try alternative domain values,
and if all fail, will backtrack up a depth. There is no implementation of pruning domain values
and undoing a prune when backtracking up a level.
I did develop code to create a persistent tree representation of all paths that have been explored,
creating a recursively generated tree with double\sphinxhyphen{}linked nodes such that paths from a node
can be traversed up or down the tree.
This structure could be used to store domain changes from visting node, which could be used
to undo domain pruning when backtracking.
However, time constraints (ha!) prevented me from incorporating this into the solver.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; make a tree object that can return values recursing up the tree from a leaf}
\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{make\PYGZhy{}tree}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{(}\PYG{k}{let}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{depth}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{n+nf}{root}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{hash\PYGZhy{}table}\PYG{+w}{ }\PYG{n+nv}{:children}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{n+nv}{:depth}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{n+nv}{:value}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{       }\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{add\PYGZhy{}node}\PYG{+w}{ }\PYG{n+nv}{parent}\PYG{+w}{ }\PYG{n+nv}{value}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{parent\PYGZhy{}node}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{n+nv}{parent}\PYG{+w}{ }\PYG{n+nv}{parent}\PYG{+w}{ }\PYG{n+nv}{root}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{             }\PYG{p}{(}\PYG{n+nf}{node\PYGZhy{}depth}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{parent\PYGZhy{}node}\PYG{+w}{ }\PYG{n+nv}{:depth}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{             }\PYG{p}{(}\PYG{n+nf}{node}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{hash\PYGZhy{}table}
\PYG{+w}{                     }\PYG{n+nv}{:children}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{                     }\PYG{n+nv}{:depth}\PYG{+w}{ }\PYG{n+nv}{node\PYGZhy{}depth}
\PYG{+w}{                     }\PYG{n+nv}{:parent}\PYG{+w}{ }\PYG{n+nv}{parent\PYGZhy{}node}
\PYG{+w}{                     }\PYG{n+nv}{:value}\PYG{+w}{ }\PYG{n+nv}{value}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{parent\PYGZhy{}node}\PYG{+w}{ }\PYG{n+nv}{:children}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cons}\PYG{+w}{ }\PYG{n+nv}{node}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{parent\PYGZhy{}node}\PYG{+w}{ }\PYG{n+nv}{:children}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{\PYGZgt{}}\PYG{+w}{ }\PYG{n+nv}{node\PYGZhy{}depth}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{set!}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{+w}{ }\PYG{n+nv}{node\PYGZhy{}depth}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nv}{node}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{    }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{print}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{(}\PYG{n+nf}{post}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tree depth:}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{n+nv}{depth}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{structure}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{n+nv}{root}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{    }\PYG{p}{(}\PYG{k}{define}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{values\PYGZhy{}from\PYGZhy{}node}\PYG{+w}{ }\PYG{n+nv}{node}\PYG{p}{)}
\PYG{+w}{      }\PYG{c+c1}{;(post \PYGZdq{}values\PYGZhy{}from\PYGZhy{}node, starting at depth:\PYGZdq{} (node :depth))}
\PYG{+w}{      }\PYG{c+c1}{; recurse up the tree from a node to get list of values}
\PYG{+w}{      }\PYG{p}{(}\PYG{k}{let*}\PYG{+w}{ }\PYG{n+nv}{rec\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{n}\PYG{+w}{ }\PYG{n+nv}{node}\PYG{p}{)}
\PYG{+w}{                      }\PYG{p}{(}\PYG{n+nf}{vals}\PYG{+w}{ }\PYG{o}{\PYGZsq{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{(}\PYG{k}{cond}
\PYG{+w}{          }\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{eq?}\PYG{+w}{ }\PYG{n+no}{\PYGZsh{}f}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{n}\PYG{+w}{ }\PYG{n+nv}{:parent}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{            }\PYG{n+nv}{vals}\PYG{p}{)}
\PYG{+w}{          }\PYG{p}{(}\PYG{k}{else}
\PYG{+w}{            }\PYG{p}{(}\PYG{n+nf}{rec\PYGZhy{}loop}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{n}\PYG{+w}{ }\PYG{n+nv}{:parent}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nb}{cons}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{n}\PYG{+w}{ }\PYG{n+nv}{:value}\PYG{p}{)}\PYG{+w}{ }\PYG{n+nv}{vals}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{+w}{    }\PYG{p}{(}\PYG{k}{lambda}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nf}{msg}\PYG{+w}{ }\PYG{o}{.}\PYG{+w}{ }\PYG{n+nv}{args}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Variable Selection}
\label{\detokenize{index:variable-selection}}
\sphinxAtStartPar
The implementation of choosing the next variable to be solved is naive;
it simply iterates through the note list in order. Allowing solving order
to be indicated or optimized would reduce paths explored. For example, in
bass line implementation, one could work either forwards or backwards from the target.


\section{Value Selection}
\label{\detokenize{index:value-selection}}
\sphinxAtStartPar
Similar to variable selection, value selection at present simply iterates
through the domain values. Work is underway to improve this with random urn implementation.


\chapter{Future Work}
\label{\detokenize{index:future-work}}
\sphinxAtStartPar
There are a number of areas of future work I intend to explore.


\section{Constraint Propagation}
\label{\detokenize{index:constraint-propagation}}
\sphinxAtStartPar
As discussed above, propagation of constraints is the the first major deficiency.
Constraint propagation will significantly speed up execution, though execution time
does not seem to be much of an issue even with the current implementation. This
could be an issue solving longer lines.


\section{Advanced Pruning}
\label{\detokenize{index:advanced-pruning}}
\sphinxAtStartPar
Given the domain\sphinxhyphen{}specific constraint implementation, it would be reasonably straight\sphinxhyphen{}forward
to add a special type of constraint intended to prune variable domains prior to solving,
which could speed up execution. For example, a user might specify that all notes up the
targeting final note should be diatonic to the tonic key. Such a constraint could
thus prune the domain for notes 1 to 3 to be diatonic only, cutting the number of
branches to be explored down significantly.


\section{Assignment}
\label{\detokenize{index:assignment}}
\sphinxAtStartPar
Notes are assigned one at a time, but this is not an ideal heuristic for simulating
how musicians think. For example, when playing a bass line, a musicain is likely
to think “I can walk or arpeggiate”, determing which based on available range
and what they have recently done, and evaluating whether several candidates will work
at one time. The solver could draw from a bank of patterns to try various compound
selections first rather than brute force traversal through all paths of the state space.


\section{Constraint Macro Framework}
\label{\detokenize{index:constraint-macro-framework}}
\sphinxAtStartPar
While implementing the constraints as boolean predicates is straightforward, it does
require the developer to be somewhat familiar with the implementation details of
the csp solver. A higher\sphinxhyphen{}level framework built on Lisp macros could be implemented
to reduce the amount of code necessary and to reduce how much must be understood
by the authors of the constraints.


\section{Solver Instantiation}
\label{\detokenize{index:solver-instantiation}}
\sphinxAtStartPar
Creating, initializing, and setting up a solver with constraints and context variables
is currently a fairly verbose affair. This is an area where Lisp macros could
again allow a much more succint and readable API for users of the solver.


\section{Stochastic Heuristics}
\label{\detokenize{index:stochastic-heuristics}}
\sphinxAtStartPar
When choosing a next candidate domain value, the current implementation either
takes the next one, or a random value. The addition of preference constraints
to help choose candidates in more musically meaningful ways would be a fruitful
area to explore. This could potentially allow one to implement preference rules
such as \sphinxstyleemphasis{“if the last three notes have ascended, increase the probability of
the next note descending”}.


\chapter{Conclusion}
\label{\detokenize{index:conclusion}}
\sphinxAtStartPar
As a first attempt at solving musical line building with a constraint solver,
I feel the project has been a success. Execution is fast enough to allow
generating a bass line in perpetuity. While still somewhat verbose, specifying
rules in a similar way to how one thinks of musical constraints works well.
One can read, for example, the set of constraint registrations to make an
arpeggiated bass line and understand right away what the outcome is intended to be.

\sphinxAtStartPar
Breaking up the constraints into (solved) notes and (pre\sphinxhyphen{}assigned) context variables is
also successful, and makes domain specific problems much easier to reason about and
to design constraints for then would be the case with all numerical variables, with
no destinction between context and outcome. It is also more reflective of
how improvisers and composers think of the problems: the chord progression and key
are a given, the notes to realize it are improvised.

\sphinxAtStartPar
The project runs well in Scheme for Max and, I believe, has the potential to be
a valuable contribution to the available offerings for computer assisted composition
in the Max environment, such as the Bach project.



\renewcommand{\indexname}{Index}
\printindex
\end{document}