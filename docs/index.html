<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Objective &#8212; Musical Constraint Satisfication Programming Project - Iain C.T. Duncan</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css?v=def86cc0" />
    
    <script src="_static/documentation_options.js?v=f2a433a1"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="#">Musical Constraint Satisfication Programming Project - Iain C.T. Duncan</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Objective</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
</div>
<section id="objective">
<h1>Objective<a class="headerlink" href="#objective" title="Link to this heading">¶</a></h1>
<p>The objective of this project is to implement an algorithmic musical line builder as
a constraint satisfaction problem using a custom-built domain-specific solver in the
Scheme programming language such that it can be run in the Scheme for Max computer music environment.
The solver will allow the user (i.e., the programmer using the solver in a Scheme
for Max program) to specify constraints by registering predicate functions that take
a standardized set of arguments and that work over symbolic musical representation.
It is assumed that the user has familiarity with the Scheme language, but not necessarily
with the details of CSP programming, and that the user is comfortable with basic music theory.
The project will provide a Scheme message-passing-style object that acts as a CSP solver,
along with a library of symbolic functions allowing the user to make new constraint predicates
relatively easily, working with familiar musical symbols.</p>
<p>The test application for the project is a program that builds idiomatic
jazz bass lines when given a key, a starting note, and a symbolic chord progression such as IImin7 - V7 - IMaj7.
The test application will return the realized bass line as a list of symbolic note names (e.g., D4 F4 A4).</p>
</section>
<section id="specific-goals">
<h1>Specific Goals<a class="headerlink" href="#specific-goals" title="Link to this heading">¶</a></h1>
<p>Specific goals of the implementation are:</p>
<blockquote>
<div><ul class="simple">
<li><p>Constraints may be either local (run over one variable) or global. A solution will satisfy all local and global constraints.</p></li>
<li><p>Constraints may be easily created in high-level Scheme code using an included set of musical primitives.</p></li>
<li><p>Multiple runs of the program will create different bass lines, i.e., the CSP solver is
not looking for the first or best solution, but rather a stochastically chosen acceptable solution.</p></li>
<li><p>The solver will find a solution, if one exists.</p></li>
<li><p>If the constraints given result in an unsolvable problem, the solver will determine this and return false.</p></li>
<li><p>Solutions will be rendered bar-by-bar, such that it would be possible for the solver to be used
to play algorithmically-generated lines in real time and for infinite time, so long as the solver
can generate a bar’s notes in less time than is used to play a bar.</p></li>
<li><p>The solver will accept constraints using symbols of all note values (i.e., either C# or Db may be used)
but will not necessarily return values translated into symbols appropriate to the key (i.e., it may
use either Db or C# for note values, regardless of the context)</p></li>
</ul>
</div></blockquote>
</section>
<section id="program-structure">
<h1>Program Structure<a class="headerlink" href="#program-structure" title="Link to this heading">¶</a></h1>
<p>The solver is implemented as a Scheme function-as-an-object that receives symbolic messages and that stores local values in private scope.
This is implemented by using a builder function that creates a local let block, and returns a lambda function with
access to the values in the let. The returned function acts as the object, and methods can be called by passing
symbolic messages, which are dispatched to similarly named functions with the local scope.
By implementing the solver as a self-contained object, the user of the solver must thus only load the code defining the CSP solver
builder function and any musical library functions used to build constraints.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; example of the message passing object structure used</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">make-obj</span><span class="p">)</span>
<span class="w">  </span><span class="c1">; object state is stored in a hash-table with keyword keys</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="k">_</span><span class="w"> </span><span class="p">(</span><span class="nf">hash-table</span>
<span class="w">              </span><span class="nv">:var-1</span><span class="w"> </span><span class="no">#t</span>
<span class="w">              </span><span class="nv">:var-2</span><span class="w"> </span><span class="no">#f</span><span class="p">)))</span>

<span class="w">    </span><span class="c1">; a method to return a state var</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">get-var</span><span class="w"> </span><span class="nv">var-name</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">var-name</span><span class="p">))</span>

<span class="w">    </span><span class="c1">; a method to update a state var</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">set-var!</span><span class="w"> </span><span class="nv">var-name</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">var-name</span><span class="p">)</span><span class="w"> </span><span class="nv">val</span><span class="p">))</span>

<span class="w">    </span><span class="c1">; dispatch method is a lambda returned by make-obj</span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">msg</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span><span class="w"> </span><span class="nv">args</span><span class="p">))))</span>

<span class="c1">; make an object</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="nv">my-obj</span><span class="w"> </span><span class="p">(</span><span class="nf">make-obj</span><span class="p">))</span>
<span class="c1">; set var-2 to value of var-1</span>
<span class="p">(</span><span class="nf">my-obj</span><span class="w"> </span><span class="ss">&#39;set-var</span><span class="w"> </span><span class="nv">:var-2</span><span class="w"> </span><span class="p">(</span><span class="nf">my-obj</span><span class="w"> </span><span class="ss">&#39;get</span><span class="w"> </span><span class="ss">&#39;var-1</span><span class="p">))</span>
</pre></div>
</div>
<p>The solver is set up via an explicit initialization method, allowing the same solver to be reused for subsequent
bars by setting only the values that need to change for each bar by reinitializing the solver object.</p>
<p>Constraints are added via a registration function that accepts a predicate function, the variable over which it runs,
and a symbolic name. Global constraints are similarly added, but are assumed to have access to all notes.</p>
<p>The solver’s <strong>solve</strong> method runs the solver, both returning a list of symbolic notes
and updating the internal store of the notes.</p>
</section>
<section id="high-level-implementation-of-the-solver">
<h1>High-level Implementation of the Solver<a class="headerlink" href="#high-level-implementation-of-the-solver" title="Link to this heading">¶</a></h1>
<p>The solver contains two kinds of domain variables: note variables and context variables.</p>
<p>Notes are stored in a list and are assumed to be empty prior to solving, though they are not necessarily so.
The domain of note variables is separately maintained in local state, and is set up during initialization
to contain MIDI note names across a pre-determined range (e.g., C0 to B5).
The number of note variables is determined by an argument to the object builder,
and the problem is considered to be solved when values have been successfully assigned to
all note variables, satisfying all local and global constraints.
The use of MIDI note symbols rather than note numbers was chosen to facilitate interactive
debugging and exploratory coding.</p>
<p>Context variables are symbolic state variables for the solver and are assumed to be
pre-assigned prior to the solve method. While they can be changed in between calls to the solve method,
the solver does not assign context variables as part of finding a solution, and thus
does not maintain domain values for each context variable either.</p>
<p>As the solver solves bar-by-bar, it must be aware of the bar to which it is leading.
For example, to build an idiomatic jazz bass line with one chord per bar and four notes per bar,
where each bar begins with the root of the chord,
note 5 of the solution will always be the root of the subsequent bar’s chord, and note
4 will always be either a chromatic or diatonic neighbour tone of this target.
Thus, we require the solver to have context for the current bar and the subsequent bar.</p>
<p>The context variables used by the solver are the following:</p>
<blockquote>
<div><dl class="simple">
<dt>tonic</dt><dd><p>The home key for the progression, as a pitch-class symbol (‘C, ‘Db, etc.)</p>
</dd>
<dt>tonality</dt><dd><p>The tonality of the home key, as a symbol of ‘major, ‘minor, or ‘blues.</p>
</dd>
<dt>root</dt><dd><p>The root of the chord for the line, as a Roman numeral symbol (‘I, ‘IV, etc.)</p>
</dd>
<dt>quality</dt><dd><p>The chord quality for the line, as a chord symbol (‘Maj-7, ‘Min-7, etc.)</p>
</dd>
<dt>target</dt><dd><p>The chord root for the next bar, as a Roman numeral</p>
</dd>
<dt>target-q</dt><dd><p>The chord quality of the target chord, as a chord symbol</p>
</dd>
</dl>
</div></blockquote>
<p>Initialization prior to solving for a bar thus consists of passing a hash-table
of context variables to the <strong>init</strong> method, which will copy values into the local
context state, and initialize the note variables to empty.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; a simplified example of building and running a solver</span>
<span class="c1">; the first argument to the solver is how many notes should be returned per bar</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="nv">csp</span><span class="w"> </span><span class="p">(</span><span class="nf">make-csp</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span>

<span class="c1">; add a local and global constraint</span>
<span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-constraint</span><span class="w"> </span><span class="nv">chord-root?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="ss">&#39;n0-root</span><span class="p">)</span>
<span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-global-constraint</span><span class="w"> </span><span class="p">(</span><span class="nf">intv-under?</span><span class="w"> </span><span class="ss">&#39;maj-3</span><span class="p">))</span>

<span class="c1">; initialize the csp with context variables</span>
<span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;init</span><span class="w"> </span><span class="nv">csp</span><span class="w"> </span><span class="p">(</span><span class="nf">hash-table</span>
<span class="w">                  </span><span class="ss">&#39;tonic</span><span class="w"> </span><span class="ss">&#39;C</span>
<span class="w">                  </span><span class="ss">&#39;tonality</span><span class="w"> </span><span class="ss">&#39;major</span>
<span class="w">                  </span><span class="ss">&#39;root</span><span class="w"> </span><span class="ss">&#39;I</span>
<span class="w">                  </span><span class="ss">&#39;quality</span><span class="w"> </span><span class="ss">&#39;Maj-7</span>
<span class="w">                  </span><span class="ss">&#39;target</span><span class="w"> </span><span class="ss">&#39;IV</span>
<span class="w">                  </span><span class="p">))</span>

<span class="w"> </span><span class="c1">; solve</span>
<span class="w"> </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="nv">notes-out</span><span class="w"> </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;solve</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="domain-model-functions">
<h1>Domain Model Functions<a class="headerlink" href="#domain-model-functions" title="Link to this heading">¶</a></h1>
<p>The project includes a file of domain-specific helper functions to help the
user build constraints with symbolic notes and rules. These allow us to work with:</p>
<blockquote>
<div><dl class="simple">
<dt>note symbols</dt><dd><p>MIDI note symbols that indicate pitch and octave (C0, Db0, etc.)</p>
</dd>
<dt>pitch-class symbols</dt><dd><p>Symbols for the pitch alone (C, Db, D, etc.)</p>
</dd>
<dt>note numbers</dt><dd><p>MIDI note numbers from 0 to 127</p>
</dd>
<dt>roman numerals</dt><dd><p>Numerals to indicate chord function (I, II, V, etc.)</p>
</dd>
<dt>chord quality symbols</dt><dd><p>Symbols for a type of chord (Maj-7, Min-7)</p>
</dd>
<dt>interval symbols</dt><dd><p>Symbolic intervals, used to define chord qualities (min-3, prf-5, etc.)</p>
</dd>
</dl>
</div></blockquote>
<p>The helper library provides conversion functions between these symbolic and numeric
representations. A current limitation is that pitch classes are assumed to use flats only,
but the structure of the library is such that this can be easily extended
to include all symbolic note names.</p>
<p>Where possible, conversion functions are implemented to use hash-tables as a form
of caching, thus avoiding unecessary calculation during constraint execution, which
may run many times for a solve pass. Some of the conversion functions and hash-tables
(both are used identically in Scheme) are prepopulated in static code, while others are
populated dynamically when the helper library is imported.</p>
<p>The nomenclature used in helper function names is:</p>
<blockquote>
<div><dl class="simple">
<dt><strong>int</strong></dt><dd><p>refers to an integer offset of a pitch (e.g., C == 0, D ==2)</p>
</dd>
<dt><strong>note-num</strong></dt><dd><p>refers to MIDI note numbers</p>
</dd>
<dt><strong>pitch</strong></dt><dd><p>refers to symbolic pitch class (C, D, …)</p>
</dd>
<dt><strong>note</strong></dt><dd><p>refers to a symbolic note of pitch class and octave</p>
</dd>
<dt><strong>oct</strong></dt><dd><p>refers to the integer octave as used in MIDI note names</p>
</dd>
<dt><strong>interval</strong></dt><dd><p>refers to a symbolic interval (min-3, prf-4, …)</p>
</dd>
<dt><strong>rnum</strong></dt><dd><p>refers to a Roman numeral symbol (I, II, …)</p>
</dd>
<dt><strong>chord</strong></dt><dd><p>refers to a chord quality symbol (Maj7, Min7, etc.)</p>
</dd>
</dl>
</div></blockquote>
<p>Conversion functions provided by the library are named according
to the Scheme convention in which “-&gt;” indicates a type conversion.
The names use the component names listed above, with hyphens and plurals
used to indicate that a list is used for input or output.</p>
<p>The conversions functions provided are:</p>
<blockquote>
<div><ul class="simple">
<li><p>pitch-&gt;int</p></li>
<li><p>int-&gt;pitch</p></li>
<li><p>interval-&gt;semitones</p></li>
<li><p>semitones-&gt;interval</p></li>
<li><p>note-&gt;pitch</p></li>
<li><p>note-&gt;oct</p></li>
<li><p>note-&gt;note-num</p></li>
<li><p>semitones-between</p></li>
<li><p>interval-between</p></li>
<li><p>chord-intervals</p></li>
<li><p>chord-&gt;semitones</p></li>
<li><p>rnum-&gt;int</p></li>
<li><p>root-pitch</p></li>
<li><p>root-chord-&gt;note-nums</p></li>
<li><p>root-chord-&gt;pitches</p></li>
</ul>
</div></blockquote>
</section>
<section id="local-constraints">
<h1>Local Constraints<a class="headerlink" href="#local-constraints" title="Link to this heading">¶</a></h1>
<p>Constraints are implemented as boolean predicate functions with standard arguments
that give the predicate access to the solver’s state (and thus context).
Local constaints are passed a reference to the solver object; an integer corresponding
the index of the note variable; and the value being tested as a MIDI note symbol.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; a local constraint example</span>
<span class="c1">; checks if the value under test is the same pitch-class as the context</span>
<span class="c1">; variable for the tonic of key</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">is-tonic?</span><span class="w"> </span><span class="nv">csp</span><span class="w"> </span><span class="nv">var</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">tonic</span><span class="w"> </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;get-var</span><span class="w"> </span><span class="ss">&#39;tonic</span><span class="p">))</span>
<span class="w">         </span><span class="c1">; the note-&gt;pitch helper returns a pitch-class symbol from a note symbol</span>
<span class="w">         </span><span class="p">(</span><span class="nf">res</span><span class="w">   </span><span class="p">(</span><span class="nb">eq?</span><span class="w"> </span><span class="nv">tonic</span><span class="w"> </span><span class="p">(</span><span class="nf">note-&gt;pitch</span><span class="w"> </span><span class="nv">val</span><span class="p">))))</span>
<span class="w">    </span><span class="nv">res</span><span class="p">))</span>

<span class="c1">; registering the constraint, using the registration name &#39;is-tonic</span>
<span class="c1">; it is registered as running over the tonic context var and note 0</span>
<span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-constraint</span><span class="w"> </span><span class="nv">is-tonic?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">tonic</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;is-tonic</span><span class="p">)</span>
</pre></div>
</div>
<p>As constraints are registered using a reference to a function, we can also
implement higher-level functions that build constraint functions.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">is-chord-factor?</span><span class="w"> </span><span class="nv">csp</span><span class="w"> </span><span class="nv">var</span><span class="w"> </span><span class="nv">val</span><span class="w"> </span><span class="nv">factor</span><span class="p">)</span>
<span class="s">&quot;return true if note pitch class is the given factor of the chord&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">root</span><span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;get-var</span><span class="w"> </span><span class="ss">&#39;root</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">chord-q</span><span class="w"> </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;get-var</span><span class="w"> </span><span class="ss">&#39;quality</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">chord-pitches</span><span class="w"> </span><span class="p">(</span><span class="nf">root-chord-&gt;pitches</span><span class="w"> </span><span class="nv">root</span><span class="w"> </span><span class="nv">chord-q</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">val-pitch</span><span class="w"> </span><span class="p">(</span><span class="nf">note-&gt;pitch</span><span class="w"> </span><span class="nv">val</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">enh-eq?</span><span class="w"> </span><span class="nv">val-pitch</span><span class="w"> </span><span class="p">(</span><span class="nf">chord-pitches</span><span class="w"> </span><span class="nv">factor</span><span class="p">))))</span>
<span class="w">    </span><span class="nv">res</span><span class="p">))</span>

<span class="c1">; register a function that checks if the note is the third (factor 1) of the chord</span>
<span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-constraint</span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="nv">var</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">is-chord-factor?</span><span class="w"> </span><span class="nv">csp</span><span class="w"> </span><span class="nv">var</span><span class="w"> </span><span class="nv">val</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;is-third</span><span class="p">)</span>
</pre></div>
</div>
<p>During the solve process, the solver user the <strong>get-applicable-constraints</strong> method
to find all local constraints that can be run on a given assignment pass for a variable,
and runs them prior to the assignment of a value to a note variable.</p>
</section>
<section id="global-constraints">
<h1>Global Constraints<a class="headerlink" href="#global-constraints" title="Link to this heading">¶</a></h1>
<p>Global constraints are implemented as predicates that have access to the entire
list of note variables. These are checked post-assignment, with assignment reverted if
the global constraints do not pass.
In the current implementation, they do not have any way of determining the variable being assigned, and
must thus be able to handle the case of incomplete note lists by returning true
to indicate a pass.
(A future improvement would be to enable global constraint registration to indicate
which variables must be filled prior to running so that the constraint code
itself does not need to handle this, which would simplify the implementation of global
constraints for the user of the solver.)</p>
<p>In the example below, we have a constraint to check if the last note of the bar is a chromatic
neighbour of the following target note.
The constraint passes if we are missing any of the necessary domain variables
(because running it at that point is meaningless),
and checks the relationship between the fourth and fifth note if we have them.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">target-from-cn?</span><span class="w"> </span><span class="nv">csp</span><span class="w"> </span><span class="nv">notes</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;get-var</span><span class="w"> </span><span class="ss">&#39;target</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>
<span class="w">    </span><span class="c1">; we don&#39;t have enough to run the constraint, pass</span>
<span class="w">    </span><span class="no">#t</span>
<span class="w">    </span><span class="c1">; if we do, check that it is a chromatic step between notes 4 and 5</span>
<span class="w">    </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">n-note</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">t-note</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">n-num</span><span class="w"> </span><span class="p">(</span><span class="nf">note-&gt;note-num</span><span class="w"> </span><span class="nv">n-note</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">t-num</span><span class="w"> </span><span class="p">(</span><span class="nf">note-&gt;note-num</span><span class="w"> </span><span class="nv">t-note</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">t-num</span><span class="w"> </span><span class="nv">n-num</span><span class="p">)))))</span>
<span class="w">      </span><span class="nv">res</span><span class="p">)))</span>
</pre></div>
</div>
<p>With the current implementation, one could thus implement a brute-force solver using only global constraints.</p>
<p>The library of constraints includes an imperative implementation of all-diff, as well
as a more specific implementation that accepts a list of notes which must be different.
This was necessary for the test program, for example, as the chromatic neighbour
of a target root may or may not be already in the chord. We thus need a way to specify,
<em>“all notes should be different, unless the duplicated note is the chromatic neighbour as note 4”</em>.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; fail on any already assigned notes that are duplicates but have values</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">all-diff?</span><span class="w"> </span><span class="nv">csp</span><span class="w"> </span><span class="nv">notes</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">len</span><span class="w">   </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">notes</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">pass</span><span class="w">  </span><span class="no">#t</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">do</span><span class="w"> </span><span class="p">((</span><span class="nf">i</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">len</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">do</span><span class="w"> </span><span class="p">((</span><span class="nf">j</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">j</span><span class="p">)))</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="nv">len</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">eq?</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="nv">j</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">j</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">false?</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="nv">i</span><span class="p">))))</span>
<span class="w">          </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="nv">pass</span><span class="w"> </span><span class="no">#f</span><span class="p">))))</span>
<span class="w">    </span><span class="nv">pass</span><span class="p">))</span>

<span class="c1">; diff is like all-diff but takes list of note vars</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">diff?</span><span class="w"> </span><span class="nv">note-var-list</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="nv">notes</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">len</span><span class="w">   </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">notes</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">pass</span><span class="w">  </span><span class="no">#t</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">do</span><span class="w"> </span><span class="p">((</span><span class="nf">i</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">len</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">do</span><span class="w"> </span><span class="p">((</span><span class="nf">j</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">j</span><span class="p">)))</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="nv">len</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">and</span>
<span class="w">                </span><span class="p">(</span><span class="nf">in?</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">note-var-list</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nf">in?</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="nv">note-var-list</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nb">eq?</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="nv">j</span><span class="p">))</span>
<span class="w">                </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">j</span><span class="p">))</span>
<span class="w">                </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">false?</span><span class="w"> </span><span class="p">(</span><span class="nf">notes</span><span class="w"> </span><span class="nv">i</span><span class="p">))))</span>
<span class="w">            </span><span class="p">(</span><span class="k">begin</span>
<span class="w">              </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="nv">pass</span><span class="w"> </span><span class="no">#f</span><span class="p">)))))</span>
<span class="w">      </span><span class="nv">pass</span><span class="p">)))</span>
</pre></div>
</div>
</section>
<section id="constraints-for-the-test-problem">
<h1>Constraints for the Test Problem<a class="headerlink" href="#constraints-for-the-test-problem" title="Link to this heading">¶</a></h1>
<p>Given the above constraints, we have all that we need to specify an arpeggiated bass line
that always leads chromatically into the next chord.
Our rules are:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first note must be the root of the chord</p></li>
<li><p>The second and third notes must in the chord</p></li>
<li><p>None of the first three notes may be the same</p></li>
<li><p>Adjacent notes are under a major 3rd apart</p></li>
<li><p>The final note is the root of the target chord</p></li>
<li><p>The penultimate note is a chromatic neighbour of the target</p></li>
</ul>
</div></blockquote>
<p>In the test program, this is implemented as a function to add these constraints.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">add-constraints</span><span class="w"> </span><span class="nv">csp</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-constraint</span><span class="w"> </span><span class="nv">chord-root?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="ss">&#39;n0-root</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-constraint</span><span class="w"> </span><span class="nv">in-chord?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;in-chord-1</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-constraint</span><span class="w"> </span><span class="nv">in-chord?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;in-chord-2</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-constraint</span><span class="w"> </span><span class="nv">target-root?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;target-root</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-global-constraint</span><span class="w"> </span><span class="p">(</span><span class="nf">diff?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-global-constraint</span><span class="w"> </span><span class="p">(</span><span class="nf">intv-under?</span><span class="w"> </span><span class="ss">&#39;maj-3</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">csp</span><span class="w"> </span><span class="ss">&#39;add-global-constraint</span><span class="w"> </span><span class="nv">target-from-cn?</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="solver-implementation">
<h1>Solver Implementation<a class="headerlink" href="#solver-implementation" title="Link to this heading">¶</a></h1>
<p>The solving algorithm is a recursive tree walk, where the depth corresponds to the
index within the list of notes. This is implemented in the CSP object’s <strong>solve</strong> method.
The solve method contains an inner recursive function, <strong>recursive-search</strong>, which
is passed an integer signifying depth, but also has access to the note variable assignment list,
as this is in the scope of the function-object. In the current implementation,
the depth variable – which corresponds also to the index of the solved note –
is not strictly necessary, as the solver has access to the notes list in local
state. However, I added this both as an aid to debugging and because I expect
I may need for some future features, such as domain change rewinding where we
may need to keep track of where we are in the tree of state traversal.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; the main search method, fills and returns the notes vars on success</span>
<span class="c1">; can take optional positional arg of hash-table of preassignments</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">solve</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">pre-assign</span><span class="w"> </span><span class="p">(</span><span class="nf">args</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">post</span><span class="w"> </span><span class="s">&quot;csp::(solve) ctx:&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:cxt-assignments</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;notes:&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:note-assignments</span><span class="p">))</span>

<span class="w">  </span><span class="c1">; inner recursive function</span>
<span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">recursive-search</span><span class="w"> </span><span class="nv">depth</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span>
</pre></div>
</div>
<p>The first check is whether all notes have been assigned, and if this is the case,
a <strong>true</strong> value is returned up the stack.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; inner recursive function</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">recursive-search</span><span class="w"> </span><span class="nv">depth</span><span class="p">)</span>
<span class="w">  </span><span class="c1">;if assignment complete, we are done return assignment</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span>
<span class="w">    </span><span class="c1">; case done, vector of 4 notes filled, return success</span>
<span class="w">    </span><span class="c1">; executes when we get to the bottom of recuring down</span>
<span class="w">    </span><span class="p">((</span><span class="nf">all-notes-assigned?</span><span class="p">)</span>
<span class="w">       </span><span class="no">#t</span><span class="p">)</span>
<span class="w">    </span><span class="c1">; else we still have notes to fill</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span>
<span class="w">      </span><span class="o">...</span>
</pre></div>
</div>
<p>If we have not yet assigned all notes, the next note variable to solve is selected using the <strong>select-var</strong> method,
and the solver then iterates through all possible domain values for this variable,
using a Scheme named-let as a loop, with a recursively reduced list of domain values
passed into each iteration (i.e., “a list eater function” implemented as a
named-let rather than a lambda function).</p>
<p>If all domain values have been exhausted (the list is null), we return <strong>false</strong> up the stack.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; else we still have notes to fill</span>
<span class="p">(</span><span class="k">else</span>
<span class="w">  </span><span class="c1">; get the next far to fill</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">var</span><span class="w"> </span><span class="p">(</span><span class="nf">select-var</span><span class="p">)))</span>
<span class="w">    </span><span class="c1">; iterate through domain values for i</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="nv">domain-val-loop</span><span class="w"> </span><span class="p">((</span><span class="nf">vals</span><span class="w"> </span><span class="p">(</span><span class="nf">get-domain-values</span><span class="w"> </span><span class="nv">var</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="nv">vals</span><span class="p">)</span>
<span class="w">        </span><span class="c1">; case ran out of domain vals, return failure back up</span>
<span class="w">        </span><span class="p">(</span><span class="k">begin</span>
<span class="w">          </span><span class="no">#f</span><span class="p">)</span>
<span class="w">        </span><span class="c1">; else, try assigning the val, check constraints we can run so far</span>
</pre></div>
</div>
<p>If there is a domain value remaining to be tested, it is checked against constraints
applicable to the current value, and assigned if it passes. On failure, iteration continues.
Assuming we find a value for which the local constraints pass, the note variable is assigned
and we proceed to global constraints.</p>
<p>If global constraints pass, the note assignment is kept, and we proceed down one more
depth by recursively calling <strong>recursive-search</strong>, passing in the new depth.</p>
<p>In the case that assignment and local constraints succeed but global constraints fail,
the assigned note is unassigned (set back to false), and the domain value loop continues.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; get the next var to fill</span>
<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">var</span><span class="w"> </span><span class="p">(</span><span class="nf">select-var</span><span class="p">)))</span>
<span class="w">  </span><span class="c1">; iterate through domain values for i</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="nv">domain-val-loop</span><span class="w"> </span><span class="p">((</span><span class="nf">vals</span><span class="w"> </span><span class="p">(</span><span class="nf">get-domain-values</span><span class="w"> </span><span class="nv">var</span><span class="p">)))</span>
<span class="w">    </span><span class="c1">;(post &quot;domain-val-loop: domain-vals:&quot; vals)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="nv">vals</span><span class="p">)</span>
<span class="w">      </span><span class="c1">; case ran out of domain vals, return failure back up</span>
<span class="w">      </span><span class="p">(</span><span class="k">begin</span>
<span class="w">        </span><span class="c1">;(post &quot; - out of possible domain values, return #f up stack&quot;)</span>
<span class="w">        </span><span class="no">#f</span><span class="p">)</span>
<span class="w">      </span><span class="c1">; else, try assigning the val, check constraints we can run so far</span>
<span class="w">      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">passed</span><span class="w"> </span><span class="p">(</span><span class="nf">assign-if-valid</span><span class="w"> </span><span class="nv">var</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">vals</span><span class="p">))))</span>
<span class="w">        </span><span class="p">(</span><span class="k">cond</span>
<span class="w">          </span><span class="c1">; didn&#39;t pass precheck, on to next possible domain value</span>
<span class="w">          </span><span class="p">((</span><span class="nb">not</span><span class="w"> </span><span class="nv">passed</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nf">domain-val-loop</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">vals</span><span class="p">)))</span>
<span class="w">          </span><span class="c1">; passed precheck, failed globals: unset and continue domain val loop</span>
<span class="w">          </span><span class="p">((</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-global-constraints</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:note-assignments</span><span class="w"> </span><span class="nv">var</span><span class="p">)</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nf">domain-val-loop</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">vals</span><span class="p">)))</span>
<span class="w">          </span><span class="c1">; passed everything, found value, recurse onwards</span>
<span class="w">          </span><span class="c1">; if recursing fails, unset var and continue looking</span>
<span class="w">          </span><span class="p">((</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">recursive-search</span><span class="w"> </span><span class="nv">passed</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">depth</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:note-assignments</span><span class="w"> </span><span class="nv">var</span><span class="p">)</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nf">domain-val-loop</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">vals</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">else</span>
<span class="w">            </span><span class="c1">;(post &quot; - found passing domain val:&quot; passed &quot;for depth&quot; depth &quot;returning #t&quot;)</span>
<span class="w">            </span><span class="no">#t</span><span class="p">)))))))))</span>
</pre></div>
</div>
<p>In the case that a solution is found, the enclosing method, <strong>solve</strong> returns
the note assignments in addition to the side effect of having the local note assignment
list populated, this to simplify using the object.
In the event of failure, it returns false.</p>
<p>The complete implementation of the backtracking search is shown below:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; the main search method, fills and returns the notes vars on success</span>
<span class="c1">; can take optional positional arg of hash-table of preassignments</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">solve</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">pre-assign</span><span class="w"> </span><span class="p">(</span><span class="nf">args</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">post</span><span class="w"> </span><span class="s">&quot;csp::(solve) ctx:&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:cxt-assignments</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;notes:&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:note-assignments</span><span class="p">))</span>

<span class="w">  </span><span class="c1">; this works with the object vals, not so sure if that is better than having it separate</span>
<span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">recursive-search</span><span class="w"> </span><span class="nv">depth</span><span class="p">)</span>
<span class="w">    </span><span class="c1">;if assignment complete, we are done return assignment</span>
<span class="w">    </span><span class="p">(</span><span class="k">cond</span>
<span class="w">      </span><span class="c1">; case done, vector of 4 notes filled, return success</span>
<span class="w">      </span><span class="c1">; executes when we get to the bottom of recuring down</span>
<span class="w">      </span><span class="p">((</span><span class="nf">all-notes-assigned?</span><span class="p">)</span>
<span class="w">         </span><span class="no">#t</span><span class="p">)</span>
<span class="w">      </span><span class="c1">; else we still have notes to fill</span>
<span class="w">      </span><span class="p">(</span><span class="k">else</span>
<span class="w">        </span><span class="c1">; get the next var to fill</span>
<span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">var</span><span class="w"> </span><span class="p">(</span><span class="nf">select-var</span><span class="p">)))</span>
<span class="w">          </span><span class="c1">; iterate through domain values for i</span>
<span class="w">          </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="nv">domain-val-loop</span><span class="w"> </span><span class="p">((</span><span class="nf">vals</span><span class="w"> </span><span class="p">(</span><span class="nf">get-domain-values</span><span class="w"> </span><span class="nv">var</span><span class="p">)))</span>
<span class="w">            </span><span class="c1">; test first value, if good, use it and recurse</span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="nv">vals</span><span class="p">)</span>
<span class="w">              </span><span class="c1">; case ran out of domain vals, return failure back up</span>
<span class="w">              </span><span class="no">#f</span>
<span class="w">              </span><span class="c1">; else, try assigning the val, check constraints we can run so far</span>
<span class="w">              </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">passed</span><span class="w"> </span><span class="p">(</span><span class="nf">assign-if-valid</span><span class="w"> </span><span class="nv">var</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">vals</span><span class="p">))))</span>
<span class="w">                </span><span class="p">(</span><span class="k">cond</span>
<span class="w">                  </span><span class="c1">; didn&#39;t pass precheck, on to next possible domain value</span>
<span class="w">                  </span><span class="p">((</span><span class="nb">not</span><span class="w"> </span><span class="nv">passed</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">domain-val-loop</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">vals</span><span class="p">)))</span>
<span class="w">                  </span><span class="c1">; passed precheck, failed globals: unset and continue domain val loop</span>
<span class="w">                  </span><span class="p">((</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">check-global-constraints</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:note-assignments</span><span class="w"> </span><span class="nv">var</span><span class="p">)</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">domain-val-loop</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">vals</span><span class="p">)))</span>
<span class="w">                  </span><span class="c1">; passed everything, found value, recurse onwards</span>
<span class="w">                  </span><span class="c1">; if recursing fails, unset var and continue looking</span>
<span class="w">                  </span><span class="p">((</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">recursive-search</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">depth</span><span class="p">)))</span>
<span class="w">                    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">:note-assignments</span><span class="w"> </span><span class="nv">var</span><span class="p">)</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">domain-val-loop</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">vals</span><span class="p">)))</span>
<span class="w">                  </span><span class="p">(</span><span class="k">else</span>
<span class="w">                    </span><span class="c1">;(post &quot; - found passing domain val:&quot; passed &quot;for depth&quot; depth &quot;returning #t&quot;)</span>
<span class="w">                    </span><span class="no">#t</span><span class="p">)))))))))</span>
</pre></div>
</div>
</section>
<section id="limitations">
<h1>Limitations<a class="headerlink" href="#limitations" title="Link to this heading">¶</a></h1>
<section id="propagation">
<h2>Propagation<a class="headerlink" href="#propagation" title="Link to this heading">¶</a></h2>
<p>The current implementation is essentially a brute-force solver and does not (yet)
include any forward propagation of constraints.
When constraints fail at a given depth, the solver will next try alternative domain values,
and if all fail, it will backtrack up a depth. There is no implementation of pruning domain values
and undoing a prune when backtracking up a level.
I did develop code to build a tree representation of all paths that have been explored,
with double-linked nodes such that paths from a node can be traversed up or down the tree.
This structure could be used to store domain changes from visting and assigning a node, which could be used
to undo domain pruning when backtracking.
However, time constraints (ha!) prevented me from incorporating this into the current implementation.</p>
<p>The tree-walker is shown below. Nodes are implemented as Scheme hash-tables that
store the value for the note, the depth, a link to the parent, and reference to the
children as a list of hash-table notes. With this structure, one can
get the list of values set so far by walking up the tree from any node, rather
than relying on pseudo-global state, as was the case in the CSP object.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; make a tree object that can return values recursing up the tree from a leaf</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">make-tree</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">depth</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">root</span><span class="w"> </span><span class="p">(</span><span class="nf">hash-table</span><span class="w"> </span><span class="nv">:children</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="nv">:depth</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">:value</span><span class="w"> </span><span class="no">#f</span><span class="p">))</span>
<span class="w">       </span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">add-node</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">parent-node</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="nv">root</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">node-depth</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nf">parent-node</span><span class="w"> </span><span class="nv">:depth</span><span class="p">)))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">node</span><span class="w"> </span><span class="p">(</span><span class="nf">hash-table</span>
<span class="w">                     </span><span class="nv">:children</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">                     </span><span class="nv">:depth</span><span class="w"> </span><span class="nv">node-depth</span>
<span class="w">                     </span><span class="nv">:parent</span><span class="w"> </span><span class="nv">parent-node</span>
<span class="w">                     </span><span class="nv">:value</span><span class="w"> </span><span class="nv">value</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="p">(</span><span class="nf">parent-node</span><span class="w"> </span><span class="nv">:children</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="p">(</span><span class="nf">parent-node</span><span class="w"> </span><span class="nv">:children</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="nv">node-depth</span><span class="w"> </span><span class="nv">depth</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="nv">depth</span><span class="w"> </span><span class="nv">node-depth</span><span class="p">))</span>
<span class="w">        </span><span class="nv">node</span><span class="p">))</span>

<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">print</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">post</span><span class="w"> </span><span class="s">&quot;tree depth:&quot;</span><span class="w"> </span><span class="nv">depth</span><span class="w"> </span><span class="s">&quot;structure&quot;</span><span class="w"> </span><span class="nv">root</span><span class="p">))</span>

<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nf">values-from-node</span><span class="w"> </span><span class="nv">node</span><span class="p">)</span>
<span class="w">      </span><span class="c1">;(post &quot;values-from-node, starting at depth:&quot; (node :depth))</span>
<span class="w">      </span><span class="c1">; recurse up the tree from a node to get list of values</span>
<span class="w">      </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="nv">rec-loop</span><span class="w"> </span><span class="p">((</span><span class="nf">n</span><span class="w"> </span><span class="nv">node</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">vals</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
<span class="w">        </span><span class="p">(</span><span class="k">cond</span>
<span class="w">          </span><span class="p">((</span><span class="nb">eq?</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="nv">:parent</span><span class="p">))</span>
<span class="w">            </span><span class="nv">vals</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">else</span>
<span class="w">            </span><span class="p">(</span><span class="nf">rec-loop</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="nv">:parent</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="nv">:value</span><span class="p">)</span><span class="w"> </span><span class="nv">vals</span><span class="p">))))))</span>

<span class="w">    </span><span class="c1">; return the function-object from make-tree</span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">msg</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span><span class="w"> </span><span class="nv">args</span><span class="p">))))</span><span class="w"> </span><span class="c1">; end let and make-tree</span>
</pre></div>
</div>
</section>
<section id="variable-selection">
<h2>Variable Selection<a class="headerlink" href="#variable-selection" title="Link to this heading">¶</a></h2>
<p>The implementation of choosing the next variable to be solved is naive;
it simply iterates through the note list in order. Allowing solving order
to be indicated or optimized could potentially reduce the number of paths explored. For example, in
bass line implementation, one could work either forward or backward from the target.</p>
</section>
<section id="value-selection">
<h2>Value Selection<a class="headerlink" href="#value-selection" title="Link to this heading">¶</a></h2>
<p>Similar to variable selection, value selection at present simply iterates
through the domain values. Work is underway to improve this with random urn
implementation.</p>
</section>
</section>
<section id="future-work">
<h1>Future Work<a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h1>
<p>There are a number of areas of future work I intend to explore.</p>
<section id="constraint-propagation">
<h2>Constraint Propagation<a class="headerlink" href="#constraint-propagation" title="Link to this heading">¶</a></h2>
<p>As discussed above, the lack of constraint propagation is the the first major deficiency.
Constraint propagation will significantly speed up execution, though execution time
does not seem to be much of an issue even with the current implementation. This
could be an issue however for solving longer lines, as the state space over
five octaves will grow exponentially at powers of 60.</p>
</section>
<section id="advanced-pruning">
<h2>Advanced Pruning<a class="headerlink" href="#advanced-pruning" title="Link to this heading">¶</a></h2>
<p>Given the domain-specific constraint implementation, it would be reasonably straightforward
to add a special type of constraint intended to prune variable domains prior to solving,
based on musical rules or heuristics, which could speed up execution significantly.
For example, a user might specify that all notes up to the final target note
should be diatonic to the tonic key. Such a constraint could
thus prune the domain for notes 1 to 3 to be diatonic only, cutting the number of
branches to be explored down significantly.</p>
</section>
<section id="assignment">
<h2>Assignment<a class="headerlink" href="#assignment" title="Link to this heading">¶</a></h2>
<p>Notes are assigned one at a time, but this is not an ideal heuristic for simulating
how musicians think. For example, when playing a bass line, a musician is likely
to think <em>“I can walk stepwise or arpeggiate”</em>, determining which based on available range
and what they have recently done, and evaluating whether several candidates will work
at one time. The solver could draw from a bank of patterns to try various compound
selections first rather than brute force traversal through all paths of the state space.</p>
</section>
<section id="constraint-macro-framework">
<h2>Constraint Macro Framework<a class="headerlink" href="#constraint-macro-framework" title="Link to this heading">¶</a></h2>
<p>While implementing the constraints as boolean predicates is straightforward, it does
require the developer to be somewhat familiar with the implementation details of
the solver. A higher-level framework built on Lisp macros could be implemented
to reduce the amount of code necessary and to reduce how much must be understood
by the users making constraints.</p>
</section>
<section id="solver-instantiation">
<h2>Solver Instantiation<a class="headerlink" href="#solver-instantiation" title="Link to this heading">¶</a></h2>
<p>Creating, initializing, and setting up a solver with constraints and context variables
is currently a fairly verbose affair. This is an area where Lisp macros could
again allow a much more succint and readable API for users of the solver.</p>
</section>
<section id="stochastic-heuristics">
<h2>Stochastic Heuristics<a class="headerlink" href="#stochastic-heuristics" title="Link to this heading">¶</a></h2>
<p>When choosing the next candidate domain value, the current implementation either
takes the next one, or a random value. The addition of preference constraints
to help choose candidates in more musically meaningful ways would be a fruitful
area to explore. This could potentially allow one to implement preference rules
such as <em>“if the last three notes have ascended, increase the probability of
the next note descending”</em>. These rules could perhaps be implemented using
a higher-order Markov chain to enable some higher-level musical variety.</p>
</section>
</section>
<section id="conclusion">
<h1>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h1>
<p>As a first attempt at solving musical line building as a constraint satisfaction problem
with a custom solver,
I feel the project has been a success. Execution is fast enough to allow
generating a bass line in perpetuity. While still somewhat verbose, specifying
rules in a similar way to how one thinks of musical constraints works well.
For example, one can read the set of constraint registrations to make an
arpeggiated bass line and understand right away what the outcome is intended to be.</p>
<p>Breaking up the constraints into (solved) notes and (pre-assigned) context variables is
also successful, and makes domain specific problems much easier to reason about (and
to design constraints for) than would be the case with purely numerical variables that
make no destinction between musical context and the line. It is also more reflective of
how improvisers and composers think of the problem in homophonic improvised music:
the chord progression and key are predetermined, while the notes to realize it are improvised,
choosing from harmonic constraints that determine the genre of music. For example,
a style-imitation program designed this way would use different constraints for
different eras of jazz music as the melodic and harmonic vocabulary changed over time.</p>
<p>The project runs well in Scheme for Max and, I believe, has the potential to be
a valuable contribution to the available offerings for computer assisted composition
in the Max environment, such as the Bach project. I intend to continue to work
on the project, with the intent of publishing more complete versions as part
of the Scheme for Max project.</p>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="#">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Objective</a></li>
<li><a class="reference internal" href="#specific-goals">Specific Goals</a></li>
<li><a class="reference internal" href="#program-structure">Program Structure</a></li>
<li><a class="reference internal" href="#high-level-implementation-of-the-solver">High-level Implementation of the Solver</a></li>
<li><a class="reference internal" href="#domain-model-functions">Domain Model Functions</a></li>
<li><a class="reference internal" href="#local-constraints">Local Constraints</a></li>
<li><a class="reference internal" href="#global-constraints">Global Constraints</a></li>
<li><a class="reference internal" href="#constraints-for-the-test-problem">Constraints for the Test Problem</a></li>
<li><a class="reference internal" href="#solver-implementation">Solver Implementation</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a><ul>
<li><a class="reference internal" href="#propagation">Propagation</a></li>
<li><a class="reference internal" href="#variable-selection">Variable Selection</a></li>
<li><a class="reference internal" href="#value-selection">Value Selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#future-work">Future Work</a><ul>
<li><a class="reference internal" href="#constraint-propagation">Constraint Propagation</a></li>
<li><a class="reference internal" href="#advanced-pruning">Advanced Pruning</a></li>
<li><a class="reference internal" href="#assignment">Assignment</a></li>
<li><a class="reference internal" href="#constraint-macro-framework">Constraint Macro Framework</a></li>
<li><a class="reference internal" href="#solver-instantiation">Solver Instantiation</a></li>
<li><a class="reference internal" href="#stochastic-heuristics">Stochastic Heuristics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>

  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="#">Musical Constraint Satisfication Programming Project - Iain C.T. Duncan</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Objective</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Iain C.T. Duncan.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>